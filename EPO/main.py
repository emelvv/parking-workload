import math

def estimate_parking_occupancy(cost, distance, spots):
    """
    Оценивает загруженность парковки (0-1) на основе параметров.
    Новая модель: учитываем привлекательность местоположения и конкуренцию.
    """
    # 1. Базовый спрос на парковку в зависимости от расстояния до центра
    # В центре (0 км) спрос максимальный, на окраине (5+ км) - минимальный
    if distance <= 0.5:
        location_demand = 0.95  # Центр - очень высокий спрос
    elif distance <= 1:
        location_demand = 0.85  # Близко к центру - высокий спрос
    elif distance <= 2:
        location_demand = 0.70  # Недалеко - средний спрос
    elif distance <= 5:
        location_demand = 0.50  # Далеко - низкий спрос
    else:
        location_demand = 0.30  # Окраина - очень низкий спрос
    
    # 2. Влияние цены - более реалистичное
    # Бесплатные парковки почти всегда заняты, цена снижает спрос постепенно
    if cost == 0:
        price_factor = 1.0  # Бесплатно - максимальный спрос
    elif cost <= 30:
        price_factor = 0.9  # Очень дешево
    elif cost <= 70:
        price_factor = 0.7  # Дешево
    elif cost <= 150:
        price_factor = 0.5  # Средняя цена
    elif cost <= 300:
        price_factor = 0.3  # Дорого
    else:
        price_factor = 0.1  # Очень дорого
    
    # 3. Влияние количества мест
    # Меньше мест = выше вероятность что конкретное место занято
    if spots == 1:
        spots_factor = 0.95  # Одно место - почти всегда занято в хорошей локации
    elif spots <= 5:
        spots_factor = 0.85  # Мало мест
    elif spots <= 20:
        spots_factor = 0.70  # Среднее количество
    elif spots <= 50:
        spots_factor = 0.50  # Много мест
    else:
        spots_factor = 0.30  # Очень много мест
    
    # 4. Комбинируем факторы
    # Используем взвешенное среднее, а не умножение
    base_probability = location_demand * 0.5 + price_factor * 0.3 + spots_factor * 0.2
    
    # 5. Корректируем на основе реальных наблюдений
    # Бесплатная парковка в центре должна быть почти всегда занята
    if cost == 0 and distance <= 0.5:
        base_probability = max(base_probability, 0.9)
    
    # Очень дорогая парковка должна быть почти всегда пуста
    if cost >= 500:
        base_probability = min(base_probability, 0.1)
    
    # Гарантируем разумные границы
    probability = max(0.05, min(0.95, base_probability))
    
    return round(probability, 3)

# Тестирование
if __name__ == "__main__":
    test_cases = [
        (0, 0.1, 1, "Бесплатная парковка прямо в центре, 1 место"),
        (50, 0.5, 10, "Недорогая парковка недалеко от центра"),
        (150, 2, 50, "Средняя цена, 2 км от центра"),
        (300, 5, 100, "Дорогая парковка на окраине"),
        (1000, 1, 5, "Очень дорогая, но близко к центру"),
        (10000, 2, 1, "Запредельная цена"),
        (0, 3, 5, "Бесплатная, но далеко от центра"),
        (100, 0.2, 2, "Умеренная цена, очень близко"),
        (0, 0.1, 100, "Бесплатная в центре, много мест"),
        (30, 1, 10, "Дешевая парковка в 1 км от центра")
    ]
    
    print("ТЕСТИРОВАНИЕ ИСПРАВЛЕННОЙ МОДЕЛИ:")
    for cost, distance, spots, desc in test_cases:
        prob = estimate_parking_occupancy(cost, distance, spots)
        print(f"{desc}: {prob*100:.1f}%")